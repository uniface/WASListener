<?xml version='1.0' encoding='UTF-8' ?>
<!-- Created by Uniface - (C) Rocket Software B.V. All rights reserved -->
<!DOCTYPE UNIFACE PUBLIC "UNIFACE.DTD" "UNIFACE.DTD">
<UNIFACE release="10.4" repversion="8" xmlengine="2.0">
<TABLE>
<DSC name="ULIBSNP" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="0" charset=".U">
<FLD name="UNAME" seqno="1" type="S" level="2" pack="0" scale="0" length="60"
 pointer="0" inum="1" ufocc="0" mandatory="yes" idxnum="1" idxsnr="101" />
<FLD name="UKVERSION" seqno="2" type="N" level="2" pack="10" scale="0" length="2"
 pointer="0" inum="1" ufocc="0" idxnum="2" idxsnr="1" />
<FLD name="UMVERSION" seqno="3" type="N" level="2" pack="10" scale="0" length="2"
 pointer="0" inum="1" ufocc="0" idxnum="3" idxsnr="1" />
<FLD name="UDESCR" seqno="4" type="S" level="2" pack="13" scale="0" length="256"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UTIMESTAMP" seqno="5" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UPURPOSE" seqno="6" type="S" level="2" pack="1" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UALT_NAME" seqno="7" type="S" level="2" pack="13" scale="0" length="128"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UKEYWORDS" seqno="8" type="S" level="2" pack="13" scale="0" length="256"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UWAORDER" seqno="9" type="N" level="2" pack="7" scale="0" length="5"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCOMMENT" seqno="10" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",0,0,0,,1,0,1,\1D,0,0,0,," />
</DSC>
<OCC>
<DAT name="UNAME">USCRIPT_FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Library of trigger snippets for Form components</DAT>
<DAT name="UTIMESTAMP">2022-06-13T15:17:47.00</DAT>
<DAT name="UPURPOSE">N</DAT>
</OCC>
</TABLE>
<TABLE>
<DSC name="USNP" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="0" charset=".U">
<FLD name="UTIMESTAMP" seqno="1" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UNAME" seqno="2" type="S" level="2" pack="0" scale="0" length="60"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,4" idxsnr="103,1" />
<FLD name="USYNTAX" seqno="3" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,4" idxsnr="102,2" />
<FLD name="ULIBRARY" seqno="4" type="S" level="2" pack="0" scale="0" length="60"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,5" idxsnr="101,1" />
<FLD name="UCATEGORY" seqno="5" type="S" level="2" pack="0" scale="0" length="32"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UKVERSION" seqno="6" type="N" level="2" pack="10" scale="0" length="2"
 pointer="0" inum="1" ufocc="0" idxnum="2" idxsnr="1" />
<FLD name="UMVERSION" seqno="7" type="N" level="2" pack="10" scale="0" length="2"
 pointer="0" inum="1" ufocc="0" idxnum="3" idxsnr="1" />
<FLD name="UDESCR" seqno="8" type="S" level="2" pack="13" scale="0" length="256"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UPURPOSE" seqno="9" type="S" level="2" pack="1" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UALT_NAME" seqno="10" type="S" level="2" pack="13" scale="0" length="128"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UKEYWORDS" seqno="11" type="S" level="2" pack="13" scale="0" length="256"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UWAORDER" seqno="12" type="N" level="2" pack="7" scale="0" length="5"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCOMMENT" seqno="13" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",0,0,0,,1,0,1,\1D,0,0,0,," />
<FLD name="UTEXT" seqno="14" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C2,0,0,0,,0,0,0,," />
</DSC>
<OCC>
<DAT name="UNAME">U01_EXEC_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Invoked procedurally using activate (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;exec&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>operation exec
throws
; The exec operation of a form is fired in the following situations:
; - activate "MYFORM"
; - activate "MYFORM".exec()
; - myFormHandle-&gt;exec()
; - Select (Compile &amp;) Test from Component Editor in IDE (No parameters allowed)

; Your PARAMS block here (optional)...
; Your SCOPE  block here (optional)...
; Your VARIABLES block here (optional)...

  ; Your pre-edit code here...

  ; A form uses the edit (or display) statement to indicate it is ready to receive user input:
  ; - For a modal form, being the only form that can receive user input, this happens immediately
  ; - For non-modal forms this is postponed until all forms are ready to receive user input, which is either implicitly,
  ;   when there is no more code to execute, or explicitly using an apstart statement.
  ; During the process of showing/refreshing forms, additional triggers are fired, like read triggers (depending on
  ; the amount of painted occurrences) and/or formatToDisplay triggers.
  ; Once Uniface is idle, code execution stops and Uniface waits for user input, like pushing a button, setting focus to a
  ; field or data entry.
  ; Any user action causes an interactive trigger to be fired, once executed, Uniface becomes idle again.
  ; Successful execution of the accept and quit trigger break this loop causing this modal form to exit, after which code
  ; execution continues after the edit statement.
  ; Exceptions thrown from interactive triggers bubble up to the statement that initiated the idle mode:
  ; - For a modal form, that would be the edit (or display) statement
  ; - For a non-modal form, that would be the apstart statement (which must be present)
  ; Although it is tempting to catch exceptions by adding a try-catch around the edit (or display) or apstart statement,
  ; with the intention to correct the error situation, is complex and therefore considered bad practise. Instead, catch 
  ; exceptions in the interactive triggers itself, where the call-stack and the context is clear.
  ; Obviously, catching exceptions for reporting is fine.
  edit

  ; Your post-edit code here...

  ; Return execution status:
  ;   return 0    ; return &gt;= 0 typically indicates a successful execution
  ;   return -1   ; return &lt; 0 typically indicates an error during execution
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U021_INIT</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Invoked when component gets loaded</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;init&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>operation init
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U022_CLEANUP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Invoked when instance gets unloaded</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;cleanup&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>operation cleanup
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U04_ACCEPT_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^ACCEPT" (e.g. GOLD-A) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;accept&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger accept
throws
; This trigger is fired by a macro ^ACCEPT (GOLD-A, CTRL-A), or activate "MYFORM".accept(), and exits the form component
; It is typically used to accept any data changes and then exit
; Pre-condition: Data on the active path is successfully validated

  ; Your implementation here...

  ; Return &gt;=0 to continue component exit ($status is 9 after edit statement in exec operation)
  ; Return &lt;0 to prevent component exit
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U04_QUIT_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^QUIT" (e.g. GOLD-Q or ESC) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;quit&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger quit
throws
; This trigger is fired by a macro ^QUIT (GOLD-Q), or activate "MYFORM".quit(), and exits the form component
; It is typically used to cancel any data changes and exit
; Pre-condition: None, unlike the accept and store trigger

  ; Your implementation here...  

  ; Return &gt;=0 to continue component exit ($status is 10 after edit statement in exec operation)
  ; Return &lt;0 to prevent component exit
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U04_RECEIVEMESSAGE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when postmessage is received</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;receiveMessage&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger receiveMessage
throws
; $result contains source indication:
;   "message" - trigger receiveMessage was fired by postmessage statement
;               $msgid contains the message id
;               $msgdata contains the message data
;               $msgsrc contains the message source
;   "Timeout" - trigger receiveMessage was fired by $TIMEOUT as configured in your assignment file

; Your VARIABLES block here (optional)...

  ; Your implementation here, e.g.:
  selectcase $uppercase($result)
  case "MESSAGE"
    ; Trigger fired by postmessage statement

    selectcase $uppercase($msgid)
    case "MSG1"
      ; Trigger fired by postmessage with message Id "MSG1"

      ; Your implementation here...

    case "MSG2"
      ; Trigger fired by: postmessage instanceName, "MSG2", ...

      ; Your implementation here...

    endselectcase

  case "TIMEOUT"
    ; Trigger fired by $TIMEOUT
    ; $TIMEOUT can be set in the [SETTINGS] section of your assignment file
    ; and generates a TIMEOUT message after an inactive period.

    ; Your implementation here...

  endselectcase

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U061_PREACTIVATE_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired before activation of an operation (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;preActivate&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger preActivate
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U062_POSTACTIVATE_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired after activation of an operation (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;postActivate&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger postActivate
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U071_GETFOCUS_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when non-modal form gets focus (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;getFocus&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger getFocus
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U071_LOSEFOCUS_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when non-modal is about to lose focus (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;loseFocus&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger loseFocus
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

  ; Return execution status:
  ;   return 0    ; return &gt;= 0 to continue to lose focus
  ;   return -1   ; return &lt; 0 to prevent losing focus
  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U081_CLEAR_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^CLEAR" (e.g. GOLD-G) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;clear&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger clear
throws
; This trigger is fired by a macro ^CLEAR (GOLD-G)
; It is typically used to clear the data from the component
; Pre-condition: None, unlike the accept and store trigger

  ; Your implementation here, e.g.:
  clear

  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U082_RETRIEVE_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^RETRIEVE" (e.g. GOLD-R) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;retrieve&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger retrieve
throws
; This trigger is fired on macro ^RETRIEVE (GOLD-R)
; It is typically used to retrieve data from the database into the main entity
; Pre-condition: None, unlike the accept and store trigger
variables
  string vProfiles
endvariables

  ; Retrieve data from DBMS using current occurrence as profile
  try
    retrieve
    message "Retrieve successful"
  catch &lt;UIOSERR_OCC_NOT_FOUND&gt;, &lt;UIOSERR_OPEN_FAILURE&gt;  ; -2, -4
    message "Retrieve failed - No data found in the database."
  endtry

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U083_STORE_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^STORE" (e.g. GOLD-S) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;store&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger store
throws
; This trigger is fired on macro ^STORE (GOLD-S)
; It is typically used to invoke a data store
; Pre-condition: Data on the active path is successfully validated
variables
  string vProcErrorContext
endvariables

  ; Validate data before store to separate validation errors from store errors
  ; Validation errors are reported back to the data and will be shown by the DSP web client
  try
    validate
    try
      store
      if ($status == 1)
        message "No modifications made or entity read-only"
      else
        commit
        message "Store successful."
      endif
    catch
      vProcErrorContext = $procerrorcontext
      rollback
      throw $item("ERROR", vProcErrorContext), "Rethrow", vProcErrorContext
    endtry
  catch &lt;UGENERR_4GL_SAYS_ERROR&gt;, &lt;UVALERR_SYNTAX&gt;, &lt;UVALERR_CONSTRAINT&gt;, &lt;UVALERR_KEY_PROFILE&gt;, &lt;UVALERR_KEY_EMPTY&gt;
    ; Validation errors are already reported by the error trigger -&gt; ignore
  endtry

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U084_ERASE_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^ERASE" (e.g. GOLD-E) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;erase&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger erase
throws
; This trigger is fired on macro ^ERASE (GOLD-E)
; It is typically used to erase all data currently in the component from the database
; Pre-condition: None, unlike the accept and store trigger
variables
  string vProcErrorContext
endvariables

  ; Your implementation here, e.g.:
  try
    erase
    if ($status == 1)
      message "Erase not allowed"
    else
      commit
      message "Store successful"
    endif
  catch
    vProcErrorContext = $procerrorcontext
    rollback
    throw $item("ERROR", vProcErrorContext), "Rethrow", vProcErrorContext
  endtry

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U085_PRINT_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^PRINT" (e.g. GOLD-P) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;print&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger print
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here, e.g.:
  print/ask/preview

  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U086__MENU_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^MENU" (e.g. GOLD-C) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;menu&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger menu
throws
; This trigger is fired by fields and entities that do not have a menu trigger implemented themselves
; 
; Your VARIABLES block here (optional)...

  ; Your implementation here, e.g.:

  ; Show for what entity, occurrence and field this trigger is fired
  message/info "Menu trigger fired for cpt:&lt;$componentname&gt;"

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U087__USERKEY_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY">FRM</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^USER_KEY" (e.g. GOLD-Y) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;userKey&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger userKey
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U110_ERRREPORT</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Adds any data errors to a report of type struct</DAT>
<DAT name="UALT_NAME" xml:space='preserve'>&lt;t&gt;&lt;z&gt;reportDataErrors&lt;/z&gt;&lt;r&gt;&lt;s&gt;coll&lt;/s&gt;&lt;x&gt;partner operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>partner operation reportDataErrors
throws
; This operation looks for any data errors in the current collection and adds them to the struct report.
; The error message are expected to be available as $occproperties and $fieldproperties using the "errormsg" id.
; The value of the "errormsg" property is expected to be an indexed list with one or more error messages.
; The report is a struct and its structure represents the collection structure.
; This report activates this same operation for all its inner entities/collections.
;
; Use this report after data validation of service components, where a report needs to be returned to the caller.
; Return this report as a reference of the report struct; serialize to e.g. JSON first before returning.
; You can also use myDatapErrorReport-&gt;$dbgstring to write the report to a log in human readable format.
; Interactive components, like DSPs, USPs, and FRMs read the errors directly from the data; no need to generate this report.
params
  byref struct pErrorReport: inout
endparams
variables
  struct vCollErrors, vOccErrors
  string vFieldName, vInnerEntityName, vErrorMsg, vMsg
endvariables

  ; Initialize the error report of the current collection and add it to the report struct
  pErrorReport-&gt;*{-1} = $newstruct
  vCollErrors = pErrorReport-&gt;*{-1}
  vCollErrors-&gt;$name = "&lt;$entname&gt;.&lt;$modelname&gt;"
  
  ; Iterate all occurrences of this collection.
  forentity "&lt;$entname&gt;"
    vCollErrors-&gt;*{-1} = $newstruct
    vOccErrors = vCollErrors-&gt;*{-1}
    vOccErrors-&gt;$name = "OCC%%($curocc(&lt;$entname&gt;))"

    ; Add occurrence errors (if any); includes any key errors
    getitem/id vErrorMsg, $occproperties(&lt;$entname&gt;), "errormsg"
    if ($status &gt; 0)
      forlist vMsg in vErrorMsg
        vOccErrors-&gt;"$error"{-1} = vErrorMsg
      endfor
    endif

    ; Add field errors (if any)
    forlist vFieldName in $entinfo(&lt;$entname&gt;, "PAINTEDFIELDS")
      getitem/id vErrorMsg, $fieldproperties("%%(vFieldname).&lt;$entname&gt;"), "errormsg"
      if ($status &gt; 0)
        vOccErrors-&gt;"%%(vFieldName)" = $newstruct
        vOccErrors-&gt;"%%(vFieldName)"-&gt;"$value" = @("%%(vFieldname).&lt;$entname&gt;")
        forlist vMsg in vErrorMsg
          vOccErrors-&gt;"%%(vFieldName)"-&gt;"$error"{-1} = vMsg
        endfor
      endif
    endfor
    
    ; Add errors of inner collections (if any)
    forlist vInnerEntityName in $entinfo(&lt;$entname&gt;, "INNER")
      $collhandle(vInnerEntityName)-&gt;reportDataErrors(vOccErrors)
    endfor

    ; Occurrence has no context -&gt; delete it
    if (vOccErrors-&gt;$membercount == 0)
      vOccErrors-&gt;$parent = ""
    endif
  endfor

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U211_READ</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs read from the DBMS (retrieve)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;read&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger read
throws
; This trigger is fired as part of the retrieve process.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.
variables
  string vOrderByFieldName, vParams, vOptions, vMaxHits, vOffset
  boolean vOrderDescending
endvariables
  
  if ($rettype == 78)
    ; Read the next occurrence
    read
  
  else
    ; Read the occurrence, e.g.:
    ; - Get order-by information from e.g. $entityproperties
    getitem/id vOrderByFieldName, $entityproperties(&lt;$entname&gt;), "ORDERBY_FIELDNAME"
    if ($status &gt; 0)
      getitem/id vOrderDescending, $entityproperties(&lt;$entname&gt;), "ORDERBY_DESCENDING"
      if (vOrderDescending)
        vOrderByFieldName = "%%(vOrderByFieldName) desc"
      else
        vOrderByFieldName = "%%(vOrderByFieldName)"
      endif
    endif
    ; - Get paging info from e.g. $entityproperties
    getitem/id vMaxHits, $entityproperties(&lt;$entname&gt;), "MAX_HITS"
    if ($status &gt; 0)
      putitem/id vOptions, "maxhits", vMaxHits
    endif
    getitem/id vOffset, $entityproperties(&lt;$entname&gt;), "OFFSET"
    if ($status &gt; 0)
      putitem/id vOptions, "offset", vOffset
    endif
    ; - Get U_CONDITION, U_WHERE, or WHERE from e.g. $entityproperties and perform read
    getitem/id vParams, $entityproperties(&lt;$entname&gt;), "U_CONDITION"
    if ($status &gt; 0)
      read options vOptions u_condition (vParams) order by vOrderByFieldName
    else
      getitem/id vParams, $entityproperties(&lt;$entname&gt;), "U_WHERE"
      if ($status &gt; 0)
        read options vOptions u_where (vParams) order by vOrderByFieldName
      else
        getitem/id vParams, $entityproperties(&lt;$entname&gt;), "WHERE"
        if ($status &gt; 0)
          read options vOptions where (vParams) order by vOrderByFieldName
        else
          read options vOptions order by vOrderByFieldName
        endif
      endif
    endif
  endif

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U211_WRITE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs that need to be written to DBMS (store)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;write&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger write
throws
; This trigger is fired when Uniface writes the occurrences to the database, typically as part of a store.

  ; Your last moment field updates here, e.g.:
  ; TIMESTAMP.&lt;$entname&gt; = $datim

  write

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U211_WRITE_UP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for up-occs that need to be written to DBMS (store)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;writeUp&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger writeUp
throws
; This trigger is fired when Uniface writes an occurrence of an up entity to the database, typically as part of a store.

  ; Your last moment field updates here, e.g.:
  ; TIMESTAMP.&lt;$entname&gt; = $datim

  write

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U212_DELETE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs that need to be deleted from the DBMS</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;delete&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger delete
throws
; This trigger is fired when Uniface deletes the occurrences from the database, typically as part of a store or erase.

  delete

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U212_DELETEUP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for every up occ marked for deletion (statement store)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;deleteUp&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger deleteUp
throws
; This trigger is fired when Uniface deletes the occurrences of an up entity from the database, typically as part of a store or erase.

  delete

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U22_LOCK</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs with validation errors</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;lock&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger lock
throws
; This trigger is fired as part of a database lock request.
; Depending on the locking strategy and DBMS locking support, this can happen at different moments:
; - During read (using read/lock)
; - At field start modification on interactive Form component
; - At field assignment in ProcScript
; - During a reconnect of disconnected records
; By catching lock exceptions and return a negative value, Uniface is instructed to continue processing.
; By not catching lock exceptions Uniface will not continue processing.

  try
    lock
  catch &lt;UIOSERR_UPDATE_NOT_ALLOWED&gt;
    ; No write or delete permission for the table or file. The occurrence is read-only (cannot be locked)
    return -5
  catch &lt;UIOSERR_WRITE_FAILURE&gt;
    ; An error occurred while writing, updating, or deleting the table or file; for example, lack of disk space,
    ; no write permission, or violation of a database constraint
    ; Inform caller by returning -6 and continue processing
    return -6
  catch &lt;UIOSERR_DUPLICATE_KEY&gt;
    ; The key exists in the database but was not found in the hitlist. This occurs when the user tries to enter a duplicate key
    ; Inform caller by returning -7 and continue processing
    return -7
  catch &lt;UIOSERR_LOGON_ERROR&gt;
    ; DBMS logon error. This can occur if the database connection has been lost or the maximum number
    ; of DBMS logons has already been reached
    ; Inform caller by returning -9 and continue processing
    return -9
  catch &lt;UIOSERR_LOCK_DATA_MISMATCH&gt;
    ; Occurrence has been modified or removed since it was retrieved
    ; Reload the occurrence and continue processing
    reload
  catch &lt;UIOSERR_LOCKED&gt;
    ; Occurrence already locked; wait and try again
    ; Inform caller by returning -11 and continue processing
    return -11
  endtry

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U231_VALIDATE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs that need to be validated</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;validate&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger validate
throws
; This trigger is fired as part of the validation process and should be used to
; create occurrence-specific validation rules.
; Write one or more validation checks and return a unique negative number for every failing check;
; this negative number is used by the error trigger to report the error.
; Remove this trigger if no procedural validation is required.

  ; Your occurrence validation rules here...
  ; if (FIELD1 &gt; FIELD2)
  ;   return -1
  ; elseif (FIELD3 &lt; FIELD4)
  ;   return -2
  ; endif

  ; Validation is successful
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U232_VALIDATE_KEY</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for keys (prim/candidate) that need to be validated</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;validateKey&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger validateKey
throws
; This trigger is fired as part of the validation process and should be used to
; create primary and candidate key validation rules.
; Write one or more field validation checks and return a unique negative number for every failing check;
; this negative number is used by the error trigger to report the error.
; Remove this trigger if no key validation is required; note that the store might fail as a consequence.

  findkey "&lt;$entname&gt;", $curkey
  selectcase $status
  case 0
    ; No occurrence found with this key
    if ($foreign)
      ; Related one occurrence not found
      return -2
    endif
  case 1
    ; Occurrence with this key found in component
    if (!$foreign)
      ; Occurrence already exists in component
      return -3
    endif
  case 2
    ; Occurrence with this key found in DBMS
    if (!$foreign)
      ; Occurrence already exists in DBMS
      return -4
    endif
  elsecase
    return $status 
  endselectcase

  ; Validation is successful
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U233_ERROR_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs with validation errors (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;error&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger error
throws
; This trigger is fired when data validation of the current occurrence or key failed.
; This trigger should:
; - determine whether the validation error is to be ignored or not
;    - return &gt;=0 to indicate the error is to be ignored
;    - return &lt;0 to indicate the error is not to be ignored
; - determine the error message
; - determine the fields involved with the error for reporting purposes
; - report the error message.
variables
  string vErrorMsg, vErrors, vErrorFields, vFieldName
  numeric vKeyNr
endvariables

  ; Use all fields as default involved fields
  vErrorFields = $entinfo(&lt;$entname&gt;, "PAINTEDFIELDS")

  ; Determine the error message and involved error fields
  selectcase $error
  case 0147
    ; Error caused by occurrence trigger validateKey
    vKeyNr = $item("KEY", $dataerrorcontext)
    vErrorFields = $keyfields(&lt;$entname&gt;, vKeyNr)
    selectcase $item("STATUS", $dataerrorcontext)
    case -2
      vErrorMsg = $concat($text("%%($error)"), " - Related one-occurrence not found")
    case -3
      vErrorMsg = $concat($text("%%($error)"), " - Occurrence with the same key (%%(vKeyNr)) exists in component")
    case -4
      vErrorMsg = $concat($text("%%($error)"), " - Occurrence with the same key (%%(vKeyNr)) already exists in DBMS")
    ; ...
    elsecase
      vErrorMsg = $text("%%($error)")
    endselectcase
  case 0153       
    ; Error caused by occurrence trigger validate
    selectcase $item("STATUS", $dataerrorcontext)
    case -1
      vErrorMsg = $concat($text("%%($error)"), " - Your error message for check 1 here")
      ; vErrorFields = "..."  ; The list of fields involved with the validation error
    ; case ...
      ; ...
    elsecase
      vErrorMsg = $text("%%($error)")
      ; vErrorFields = "..."  ; The list of fields involved with this check
    endselectcase
  ; case 2004       ; No modifications allowed on occurrence of this entity
  ; case 2009       ; Occurrence locked
  ; case 2012       ; Occurrence in form does not match database occurrence
  ; case 2013       ; Occurrence does not exist
  ; ...
  elsecase
    vErrorMsg = $text("%%($error)")
    ; vErrorFields = "..."  ; The list of fields involved with the validation error
  endselectcase

  ; Form components usually do not get in situations where multiple errors need to be shown, because the Structure Editor prevents leaving modified fields/key/occurrences that are in error.
  ; For Form components, reporting the error message in the message line is sufficient.
  message vErrorMsg

  ; Return &gt;=0 to indicate the error is ignored
  ; Return &lt;0 to indicate the error is not ignored
  return -1

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U241_PRE_SERIALIZE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired before occ serialization (componentToStruct, xmlsave)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;preSerialize&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger preSerialize
throws
; This trigger is fired as part of the entity serialization process, caused by e.g. xmlsave.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U242_POST_SERIALIZE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired after occ serialization (componentToStruct, xmlsave)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;postSerialize&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger postSerialize
throws
; This trigger is fired as part of the entity serialization process, caused by e.g. xmlsave.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U243_PRE_DESERIALIZE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired before occ deserialization (StructToComponent, xmlload)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;preDeserialize&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger preDeserialize
throws
; This trigger is fired as part of the entity deserialization process, caused by e.g. xmlload.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U244_POST_DESERIALIZE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired after occ deserialization (StructToComponent, xmlload)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;postDeserialize&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger postDeserialize
throws
; This trigger is fired as part of the entity deserialization process, caused by e.g. xmlload.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U28_GETFOCUS_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when occurrence gets focus (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;getFocus&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger getFocus
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U28_LEAVE_MODIFIED_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when modified occurrence lost focus (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;leaveModified&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger leaveModified
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U28_LEAVE_MODIFIED_KEY_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when modified key lost focus (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;leaveModKey&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger leaveModifiedKey
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U28_LEAVE_PRINTED_FRM_RPT</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when occurrence has been printed (FRM RPT)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;leavePrinted&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger leavePrinted
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U29_CREATE_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^INS_OCC" (ALT-I) or "^ADD_OCC" (GOLD-AO) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;create&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger create
throws
; Fired on macro "^INS_OCC" (GOLD-IO) or "^ADD_OCC" (GOLD-AO)
; The default behavior, when not defined, is that a new occurrence gets created
; (according to the behavior as described in example_1).

; Your VARIABLES block here (optional)...

  ; Your implementation here...
  #define example_1

#ifdefined example_1
  ; Add or insert an occurremce based on the user request
  ; (this is also the behavior if this trigger is not defined at all).
  if ($rettype = 65)
     ; User invoked this trigger using "^ADD_OCC" -&gt; add occurrence after current one
     creocc "INVOICE", $curocc + 1
  else
     ; User invoked this trigger using "^INS_OCC" -&gt; insert occurrence before current one
     creocc "INVOICE", $curocc
  endif
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U29_DETAIL_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^DETAIL" (e.g. GOLD-D) or widget (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;detail&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger detail
throws
; This entity-level trigger is fired by fields that do not have a detail trigger implemented themselves
; Your VARIABLES block here (optional)...

  ; Your implementation here...
  #define example_1

#ifdefined example_1
  ; Show for what entity, occurrence and field this trigger is fired.
  message/info "Detail trigger fired for cpt:&lt;$componentname&gt;/ent:&lt;$entname&gt;{%%($curocc("&lt;$entname&gt;"))}/fld:%%($fieldname)"
#endif

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U29_HELP_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^HELP" (e.g. GOLD-H or F1) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;help&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger help
throws
; This entity-level trigger is fired by fields that do not have a help trigger implemented themselves
; Your VARIABLES block here (optional)...

  ; Your implementation here...
  #define example_1

#ifdefined example_1
  ; Show for what entity, occurrence, and field this trigger is fired
  message/info "Help trigger fired for cpt:&lt;$componentname&gt;/ent:&lt;$entname&gt;{%%($curocc("&lt;$entname&gt;"))}"
#endif

#ifdefined example_2
  ; Call the (basic) Uniface help system:
  $variation = "MYVARIATION"
  $language = "USA"
  help $text("TOPICID")
#endif

#ifdefined example_3
  ; Call external help application
  ; Specify the external help application in your INI file:
  ;   [paths]
  ;   helpdir=D:\myapp\helpUniface looks for a file in the specified directory with the name hlpTopic523.htm or hlpTopic523.html.
  help/id "TOPICID", "CHM_FILE"
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U29_MENU_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^MENU" (e.g. GOLD-C) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;menu&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger menu
throws
; This entity-level trigger is fired by fields that do not have a menu trigger implemented themselves.
; 
; Your VARIABLES block here (optional)...

  ; Your implementation here...
  #define example_1

#ifdefined example_1
  ; Show for what entity, occurrence and field this trigger is fired.
  message/info "Menu trigger fired for cpt:&lt;$componentname&gt;/ent:&lt;$entname&gt;{%%($curocc("&lt;$entname&gt;"))}"
#endif

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U29_REMOVE_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^REM_OCC" (e.g. GOLD-RO) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;remove&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger remove
throws
; This trigger is fired on macro "^REM_OCC" (e.g. GOLD-RO).
; The return execution status of this trigger determines whether the delete trigger of the current occurrence is fired,
; after which the delete trigger performs the actual mark for deletion (delete).
; This trigger does not, nor is it supposed to, perform the actual delete itself.

  ; Your mark for deletion condition here...

#ifdefined example_1
  ; Ask user to allow mark for deletion or not
  askmess/question "Mark this occurrence for removal [Y/N]?", "Yes, No"
  selectcase $status
  case 1 ; Yes
    return 0
  case 2 ; No
    return -1
  elsecase
    ; unexpected case
  endselectcase
#endif

  ; Return execution status:
  ;   return 0    ; return &gt;= 0 continues mark for deletion (fires delete trigger)
  ;   return -1   ; return &lt; 0 cancels mark for deletion (does not fire delete trigger)
  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U2P1_GETFOCUS</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when occurrence gets focus (FRM,RPT)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;getFocus&lt;/z&gt;&lt;r&gt;&lt;s&gt;phe&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger getFocus
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U2P2_GETFOCUS</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when occurrence gets focus (FRM,RPT)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;getFocus&lt;/z&gt;&lt;r&gt;&lt;s&gt;pfo&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger getFocus
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U2P3_GETFOCUS</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when occurrence gets focus (FRM,RPT)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;getFocus&lt;/z&gt;&lt;r&gt;&lt;s&gt;pbr&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger getFocus
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U311_START_MODIFICATION_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when field value is about to get modified (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;startModification&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger startModification
throws
; This trigger is fired when the user start modifying the field value.
; This trigger is used to determine whether this is allowed or not by returning the proper execution return status.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

#ifdefined example_1
  ; Some business rules determine whether the user is allowed to modify the value of the field.
  if (&lt;some_condition&gt;)
    ; Modification is not allowed
    message/error "Not allowed to change the field."
    return -1
  endif
#endif

  ; Return execution status:
  ;   return 0    ; return &gt;= 0 to continue modification
  ;   return -1   ; return &lt; 0  to prevent modification
  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U31_VALUE_CHANGED_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when field value has changed (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;valueChanged&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger valueChanged
throws
; This trigger is fired when the value of a field has changed interactively.
; This trigger is used to respond to the changed value or even to prevent it from changing.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

#ifdefined example_1
  ; Some business rule determines that the value is not allowed to be changed.
  if (&lt;$fieldname&gt; == "HALLO")
    ; You are not allowed to enter this value.
    message/error "You are not allowed to enter this value (%%(&lt;$fieldname&gt;))"
    return -1
  endif
#endif

#ifdefined example_2
  ; Some totals need to be recalculated after changing this field.
  variables
    numeric vCurocc, vTotals
  endvariables

  ; Remember which occurrence is current.
  vCurocc  = $curocc("&lt;$entname&gt;")
  ; Calculate totals
  setocc "&lt;$entname&gt;", 1
  forentity "&lt;$entname&gt;"
    vTotals += &lt;$fieldname&gt;.&lt;$entname&gt;
  endfor
  ; Make the occurrence current again.
  setocc "&lt;$entname&gt;", vCurocc
  message/info vTotals
#endif

  ; Return execution status:
  ;   return 0    ; return &gt;= 0 to continue modification and leave the field
  ;   return -1   ; return &lt; 0  to prevent leaving the changed field
  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U32_VALIDATE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields that require validation</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;validate&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger validate
throws
; This trigger is fired as part of the validation process and should be used to create field-specific validation rules.
; Write one or more field validation checks and return a unique negative number for every failing check.
; This negative number is used by the error trigger to report the error.
; Remove this trigger if no procedural validation is required.

  ; Your field validation rules here...
  ; if (&lt;$fieldname&gt;.&lt;$entname&gt; &lt; 0)
  ;   return -1
  ; elseif (&lt;$fieldname&gt;.&lt;$entname&gt; &gt; 100)
  ;   return -2
  ; endif

  ; Validation is successful.
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U34_ERROR_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields with validation errors (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;error&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger error
throws
; This trigger is fired when data validation of the current field failed.
; This trigger should:
; 1. determine whether the validation error is to be ignored or not
;    - return &gt;=0 to indicate the error is to be ignored
;    - return &lt;0 to indicate the error is not to be ignored
; 2. determine the error message
; 3. report the error message
variables
  string vErrorMsg, vDataErrorContext, vErrors
endvariables

  ; Determine error message
  selectcase $error
  case 0140
    ; Validation error caused by field trigger validate
    selectcase $item("STATUS", $dataerrorcontext)
    case -1
      ; vErrorMsg = $concat($text("%%($error)"), " - Check 1 in validate trigger failed")
      vErrorMsg = $concat($text("%%($error)"), " - Value must be between 0 and 100")
    case -2
      vErrorMsg = $concat($text("%%($error)"), " - Check 2 in validate trigger failed")
    elsecase
      vErrorMsg = $text("%%($error)")
    endselectcase
  ; case 0119       ; illegal ValRep value
  ; case 0120       ; subfield too large
  ; case 0121       ; subfield too small
  ; case 0122       ; incorrect checkdigit
  ; case 0123       ; illegal format for numeric field
  ; case 0124       ; illegal format for date field
  ; case 0125       ; illegal format for time field
  ; case 0126       ; illegal syntax format
  ; case 0127       ; illegal entry format
  ; case 0128       ; subfield too large to check
  ; case 0129       ; subfield(s) are required
  ; case 0130       ; too many subfields specified
  ; case 0138       ; illegal format for floating field
  ; ...
  elsecase
    vErrorMsg = $text("%%($error)")
  endselectcase

  ; Form components usually do not get in situations where multiple errors need to be shown, because the Structure Editor prevents leaving modified fields/key/occurrences that are in error.
  ; For Form components, reporting the error message in the message line is sufficient.
  message vErrorMsg

  ; Return &gt;=0 to indicate the error is ignored
  ; Return &lt;0 to indicate the error is not ignored
  return -1

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U35_FORMAT_DBMS_FROM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields that are read from the DBMS (read)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;formatFromDbms&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger formatFromDbms
throws
; This trigger is fired as part of the read from DBMS process.
; Make sure not to leave the context of this field, it would disrupt the trigger flow and give unpredictable results.

  ; Your conversion or decoding code here, e.g.:
  ; Data was stored encrypted using BLOWFISH in the DBMS, so decrypt it:
  &lt;$fieldname&gt;.&lt;$entname&gt; = $decode("BLOWFISH", &lt;$fieldname&gt;.&lt;$entname&gt;, "my secret key")

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U35_FORMAT_DBMS_TO</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields that are written to the DBMS (write)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;formatToDbms&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger formatToDbms
throws
; This trigger is fired as part of the write to DBMS process.
; Make sure not to leave the context of this field, it would disrupt the trigger flow and give unpredictable results.

  ; Your conversion or encoding code here, e.g.:
  ; Data is stored encrypted using BLOWFISH in the DBMS:
  &lt;$fieldname&gt;.&lt;$entname&gt; = $encode("BLOWFISH", &lt;$fieldname&gt;.&lt;$entname&gt;, "my secret key")

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U35_FORMAT_DISPLAY_FROM_FRMDSPUSP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM DSP USP ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields of which a value has been entered (DSP,USP,FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;formatFromDisplay&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger formatFromDisplay
throws
; This trigger is fired as part of the data entry process.
; Make sure not to leave the context of this field, it would disrupt the trigger flow and give unpredictable results.
; var = $format - returns the value as entered by the user
; $format = var - assigns the converted value back to the internal administration of the system.

  ; Your display deformatting code here...

#ifdefined example_1
  ; 'GOLD-*' are displayed as regular '*' characters, convert them back on data entry
  $format = $replace($format, 1, "*", "&uALL;", -1)
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U35_FORMAT_DISPLAY_TO_FRMRPTDSPUSP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields that are displayed (DSP USP FRM RPT)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;formatToDisplay&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger formatToDisplay
throws
; This trigger is fired as part of the show process.
; Make sure not to leave the context of this field, it would disrupt the trigger flow and give unpredictable results.
; var = $format - returns the internal value of the field
; $format = var - assigns the formatted value back to the system for displaying.

  ; Your display formatting code here...

#ifdefined example_1
  ; Display 'GOLD-*' characters as regular '*' characters
  $format = $replace($format, 1, "&uALL;", "*", -1)
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U36_FOCUS_GET_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when field gets focus (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;getFocus&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger getFocus
throws
; Your VARIABLES block here (optional)...

  ; Your display formatting code here...

#ifdefined example_1
  ; Set some custom styling on the current field
  putitem/id $fieldproperties("&lt;$fieldname&gt;.&lt;$entname&gt;"), "backcolor", "#FFFFCC"
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U36_FOCUS_LOSE_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when field loses focus (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;loseFocus&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger loseFocus
throws
; Your VARIABLES block here (optional)...

  ; Your display formatting code here...

#ifdefined example_1
  ; Set some custom styling on the current field
  putitem/id $fieldproperties("&lt;$fieldname&gt;.&lt;$entname&gt;"), "backcolor", ""
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U381_DETAIL_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^DETAIL" (e.g. GOLD-D) or widget (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;detail&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger detail
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U39_HELP_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^HELP" (e.g. GOLD-H or F1) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;help&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger help
throws
; This trigger is fired by fields.
; Your VARIABLES block here (optional)...

  ; Your implementation here...
  #define example_1

#ifdefined example_1
  ; Show for what entity, occurrence and field this trigger is fired.
  message/info "Help trigger fired for cpt:&lt;$componentname&gt;/ent:&lt;$entname&gt;{%%($curocc("&lt;$entname&gt;"))}/fld:%%($fieldname)"
#endif

#ifdefined example_2
  ; Call the (basic) Uniface help system:
  $variation = "MYVARIATION"
  $language = "USA"
  help $text("TOPICID")
#endif

#ifdefined example_3
  ; Call external help application
  ; Specify the external help application in your INI file:
  ;   [paths]
  ;   helpdir=D:\myapp\helpUniface looks for a file in the specified directory with the name hlpTopic523.htm or hlpTopic523.html.
  help/id "TOPICID", "CHM_FILE"
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U39_MENU_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^MENU" (e.g. GOLD-C) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;menu&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger menu
throws
; This trigger is fired by fields.
 
; Your VARIABLES block here (optional)...

  ; Your implementation here...
  #define example_1

#ifdefined example_1
  ; Show for what entity, occurrence and field this trigger is fired.
  message/info "Menu trigger fired for cpt:&lt;$componentname&gt;/ent:&lt;$entname&gt;{%%($curocc("&lt;$entname&gt;"))}/fld:%%($fieldname)"
#endif

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U39_NAV_NEXT_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^NEXT_FIELD" (e.g. GOLD-NF or TAB) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;next&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger next
throws
; This trigger is fired on macro "^NEXT_FIELD" (e.g. GOLD-NF or TAB).
; The return execution status of this trigger determines whether the navigation is performed or prohibited.
; If this trigger is not defined, the default is to navigate to the next field within the same occurrence.

  ; Your mark for deletion condition here...

#ifdefined example_1
  ; When on last field of current occurrence, then navigate to first field of next occurrence.
  if ("&lt;$fieldname&gt;" == $itemnr(-1, $entinfo("&lt;$entname&gt;", "PAINTEDFIELDS")))
    setocc "&lt;$entname&gt;", $curocc("&lt;$entname&gt;") + 1
    $prompt = $itemnr(1, $entinfo("&lt;$entname&gt;", "PAINTEDFIELDS"))
  endif
#endif

#ifdefined example_2
  ; Conditionally navigate to a specific field
  if (GENDER = "F") ; female, so prompt for maiden name
    $prompt = MAIDEN_NAME
  endif
  ; Otherwise, use default prompt sequence
#endif

  ; Return execution status:
  ;   return 0    ; return &gt;= 0 to perform the navigation
  ;   return -1   ; return &lt; 0 to prohibit the navigation
  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U39_NEV_PREVIOUS_FRM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_FRM</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on macro "^PREV_FIELD" (e.g. GOLD-PF or SHIFT-TAB) (FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;previous&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger previous
throws
; This trigger is fired on macro "^PREV_FIELD" (e.g. GOLD-PF or SHIFT-TAB).
; The return execution status of this trigger determines whether the navigation is performed or prohibited.
; If this trigger is not defined, the default is to navigate to the previous field within the same occurrence.

  ; Your mark for deletion condition here...

#ifdefined example_1
  ; When on first field of current occurrence, then navigate to last field of previous occurrence.
  if ("&lt;$fieldname&gt;" == $itemnr(1, $entinfo("&lt;$entname&gt;", "PAINTEDFIELDS")))
    setocc "&lt;$entname&gt;", $curocc("&lt;$entname&gt;") - 1
    $prompt = $itemnr(-1, $entinfo("&lt;$entname&gt;", "PAINTEDFIELDS"))
  endif
#endif

#ifdefined example_2
  ; Conditionally navigate to a specific field
  if (GENDER = "F") ; female, so prompt for maiden name
    $prompt = MAIDEN_NAME
  endif
  ; Otherwise, use default prompt sequence
#endif

  ; Return execution status:
  ;   return 0    ; return &gt;= 0 to perform the navigation
  ;   return -1   ; return &lt; 0 to prohibit the navigation
  return 0

end

</DAT>
</OCC>
</TABLE>
</UNIFACE>
