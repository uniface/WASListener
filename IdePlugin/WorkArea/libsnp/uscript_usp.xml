<?xml version='1.0' encoding='UTF-8' ?>
<!-- Created by Uniface - (C) Rocket Software B.V. All rights reserved -->
<!DOCTYPE UNIFACE PUBLIC "UNIFACE.DTD" "UNIFACE.DTD">
<UNIFACE release="10.4" repversion="8" xmlengine="2.0">
<TABLE>
<DSC name="ULIBSNP" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="0" charset=".U">
<FLD name="UNAME" seqno="1" type="S" level="2" pack="0" scale="0" length="60"
 pointer="0" inum="1" ufocc="0" mandatory="yes" idxnum="1" idxsnr="101" />
<FLD name="UKVERSION" seqno="2" type="N" level="2" pack="10" scale="0" length="2"
 pointer="0" inum="1" ufocc="0" idxnum="2" idxsnr="1" />
<FLD name="UMVERSION" seqno="3" type="N" level="2" pack="10" scale="0" length="2"
 pointer="0" inum="1" ufocc="0" idxnum="3" idxsnr="1" />
<FLD name="UDESCR" seqno="4" type="S" level="2" pack="13" scale="0" length="256"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UTIMESTAMP" seqno="5" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UPURPOSE" seqno="6" type="S" level="2" pack="1" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UALT_NAME" seqno="7" type="S" level="2" pack="13" scale="0" length="128"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UKEYWORDS" seqno="8" type="S" level="2" pack="13" scale="0" length="256"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UWAORDER" seqno="9" type="N" level="2" pack="7" scale="0" length="5"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCOMMENT" seqno="10" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",0,0,0,,1,0,1,\1D,0,0,0,," />
</DSC>
<OCC>
<DAT name="UNAME">USCRIPT_USP</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Library of trigger snippets for Static Server Page components</DAT>
<DAT name="UTIMESTAMP">2022-06-08T14:47:26.00</DAT>
<DAT name="UPURPOSE">N</DAT>
</OCC>
</TABLE>
<TABLE>
<DSC name="USNP" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="0" charset=".U">
<FLD name="UTIMESTAMP" seqno="1" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UNAME" seqno="2" type="S" level="2" pack="0" scale="0" length="60"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,4" idxsnr="103,1" />
<FLD name="USYNTAX" seqno="3" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,4" idxsnr="102,2" />
<FLD name="ULIBRARY" seqno="4" type="S" level="2" pack="0" scale="0" length="60"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,5" idxsnr="101,1" />
<FLD name="UCATEGORY" seqno="5" type="S" level="2" pack="0" scale="0" length="32"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UKVERSION" seqno="6" type="N" level="2" pack="10" scale="0" length="2"
 pointer="0" inum="1" ufocc="0" idxnum="2" idxsnr="1" />
<FLD name="UMVERSION" seqno="7" type="N" level="2" pack="10" scale="0" length="2"
 pointer="0" inum="1" ufocc="0" idxnum="3" idxsnr="1" />
<FLD name="UDESCR" seqno="8" type="S" level="2" pack="13" scale="0" length="256"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UPURPOSE" seqno="9" type="S" level="2" pack="1" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UALT_NAME" seqno="10" type="S" level="2" pack="13" scale="0" length="128"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UKEYWORDS" seqno="11" type="S" level="2" pack="13" scale="0" length="256"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UWAORDER" seqno="12" type="N" level="2" pack="7" scale="0" length="5"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCOMMENT" seqno="13" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",0,0,0,,1,0,1,\1D,0,0,0,," />
<FLD name="UTEXT" seqno="14" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C2,0,0,0,,0,0,0,," />
</DSC>
<OCC>
<DAT name="UNAME">U000_DECLARATIONS</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR">Declarations</DAT>
<DAT name="UALT_NAME" xml:space='preserve'>cpt: Declarations</DAT>
<DAT name="UTEXT" xml:space='preserve'>; Define the component variables that need to be maintained by the state manager here:
#define STATE_VARIABLES   $ComponentVariable1$&uSEP;$ComponentVariable2$&uSEP;...
; Define the entities for which the entity properties need to be maintained by the state manager here:
#define STATE_ENTITIES    ENTITYNAME1&uSEP;ENTITYNAME2&uSEP;...
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U01_EXEC_USP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY">USP</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Invoked on static web request (USP)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;exec&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>operation exec
throws
public web
; The exec operation of a USP is fired in the following situations:
; - Explicitly by a web client GET request using URL: "&lt;website&gt;/wrd/MYUSP.exec"
; - Implicitly by a web client GET request using URL: "&lt;website&gt;/wrd/MYUSP", where exec is the default operation if not specified
; - Explicitly by a web client POST request, if specified by &lt;form type="submit" action="MYUSP.exec"&gt; in the layout/skeleton
; - Implicitly by a web client POST request, if specified by &lt;form type="submit" action="MYUSP"&gt; in the layout/skeleton

; Your SCOPE  block here (optional)...
; Your VARIABLES block here (optional)...

  try
    ; webget will:
    ; - Load the data posted from the web client as disconnected records into instance
    ; - Reconnect the data with database and data already in the instance
    ; - Set active path
    ; - Fire the trigger as specified in the posted data
    webget
  catch &lt;UGENERR_4GL_SAYS_ERROR&gt;
    ; Reconnect errors are already reported by the error trigger -&gt; continue
  endtry
  ; Generate a response based on the layout and component data
  webgen

  ; Return execution status:
  ;   return 0    ; return &gt;= 0 typically indicates a successful execution
  ;   return -1   ; return &lt; 0 typically indicates an error during execution
  return 0

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U021_INIT</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Invoked when component gets loaded</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;init&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>operation init
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U022_CLEANUP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Invoked when instance gets unloaded</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;cleanup&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>operation cleanup
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U04_ACCEPT</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>RPT DSP USP SVC ESV SSV</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on unload request (by accept operation)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;accept&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger accept
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

  ; Return execution status:
  ;   return 0     ; return &gt;= 0 continues accept and unloads the the component instance
  ;   return -1    ; return &lt; 0 cancels accept and does not unload the component instance
  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U04_QUIT</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>RPT DSP USP SVC ESV SSV</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired on unload request (by quit operation)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;quit&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger quit
throws
; Your VARIABLES block here (optional)...

  ; Your implementation here...

  ; Return execution status:
  ;   return 0     ; return &gt;= 0 continues quit and unloads the component instance
  ;   return -1    ; return &lt; 0 cancels quit and does not unload the component instance
  return 0

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U04_RECEIVEMESSAGE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired when postmessage is received</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;receiveMessage&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger receiveMessage
throws
; $result contains source indication:
;   "message" - trigger receiveMessage was fired by postmessage statement
;               $msgid contains the message id
;               $msgdata contains the message data
;               $msgsrc contains the message source
;   "Timeout" - trigger receiveMessage was fired by $TIMEOUT as configured in your assignment file

; Your VARIABLES block here (optional)...

  ; Your implementation here...

#ifdefined example_1
  selectcase $uppercase($result)
  case "MESSAGE"
    ; Trigger fired by postmessage statement

    selectcase $uppercase($msgid)
    case "MSG1"
      ; Trigger fired by postmessage with message Id "MSG1"

      ; Your implementation here...

    case "MSG2"
      ; Trigger fired by: postmessage instanceName, "MSG2", ...

      ; Your implementation here...

    endselectcase

  case "TIMEOUT"
    ; Trigger fired by $TIMEOUT
    ; $TIMEOUT can be set in the [SETTINGS] section of your assignment file
    ; and generates a TIMEOUT message after an inactive period.

    ; Your implementation here...

  endselectcase
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U061_PREACTIVATE_USP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY">USP</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired before activation of an operation (USP)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;preActivate&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger preActivate
throws
; The preActivate trigger of a USP is fired just before the activation of the requested operation.
; It typically handles loading of instance specific state
variables
  string vCookie, vState, vVarList
  string vEntityName, vEntityPropertiesList, vEntityProperties
endvariables

  ; Load instance state here, e.g.:
  ; (See libsnp:USCRIPT_USP/snp:'partner operation stateLoad' for examples on saving/loading state)
  ; $instancehandle()-&gt;stateLoad()

  ; return &gt;= 0 to continue with operation activation
  ; return &lt; 0 to reject operation execution, this causes a -71 &lt;UACTERR_GET_STATE&gt; exception
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U062_POSTACTIVATE_USP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY">USP</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired after activation of an operation (USP)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;postActivate&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger postActivate
throws
; The postActivate trigger of a USP is fired just after the activation of the requested operation.
; It typically handles saving of instance specific state.
variables
  string vCookie, vState, vVarList
  string vEntityName, vEntityProperties
endvariables

  ; Save instance state here, e.g.:
  ; (See libsnp:USCRIPT_USP/snp:'partner operation stateSave' for examples on saving/loading state)
  ; $instancehandle()-&gt;stateSave()

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U063_STATELOAD_DSP_USP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY">DSP</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Load instance state (DSP,USP)</DAT>
<DAT name="UALT_NAME" xml:space='preserve'>&lt;t&gt;&lt;z&gt;stateLoad&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;partner operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>partner operation stateLoad
throws
variables
  string vState
  string vEntityName1, vEntityName2
endvariables

  ; State can be managed using different techniques.
  ; Architect the way state is maintained and choose the right technique.
  ; It can also be a combination of multiple techniques.
  ; For example (The value of &lt;$cmpStateManagedBy&gt; is specified by component property 'State Stored By'):
  #if (&lt;$cmpStateManagedBy&gt; == 1)
    ; Load instance state from cookie(s):
    getitem/id vState, $webinfo("COOKIESIN"), $instancename
    ; ...
  #elseif (&lt;$cmpStateManagedBy&gt; == 2)
    ; Load instance state from server-side state manager:
    activate "USYSSTAT".getState($item("SESSION", $webinfo("WEBSERVERCONTEXT")), $instancename, vState)
    ; ...
  #elseif (&lt;$cmpStateManagedBy&gt; == 3)
    ; Load instance state from state field(s):
    vState = STATE.ENTITY.NONDBMS
    ; ...
  #else
    ; Some other state storage...
  #endif

  ; Get variables/properties from state, e.g.:
  getitem/id $variable1$, vState, "VAR1"
  getitem/id $variable2$, vState, "VAR2"
  getitem/id $entityproperties(vEntityName1), vState, "ENT_PROPS1"
  getitem/id $entityproperties(vEntityName2), vState, "ENT_PROPS2"
  ; ...

  ; Get read-only variables/properties from state and check they are not modified, e.g.:
  getitem/id $variable1$, vState, "VAR1"
  if ($status &gt; 0)
    ; The variable is in the state, its hash should also be in the state
    if ($item("HASH1", vState) != $encode("HMAC_MD5", $variable1$))
      throw &lt;UWEBERR_HASH&gt;, "State has been tempored with", "STATEID=VAR1&uSEP;VARIABLE=$variable1$&uSEP;HASHID=HASH1&uSEP;"
    endif
  endif
  ; ...

  ; Decrypt any encrypted variables/properties, e.g.:
  ; (Consider to encrypt the complete state variable)
  $variable1$ = $decode("TDES", $variable1$, "YOUR_KEY")
  $variable2$ = $decode("TDES", $variable2$, "YOUR_KEY")
  ; ...

  ; Validate variables/properties before using them, e.g.:
  if ($variable1$ == "&lt;YOUR_CONDITION1&gt;")
    ; React when invalid, e.g. throw an exception (be careful with echoing invalid values!!!)
    throw -1, "Invalid state", "STATE_TARGET=$variable1$"
  endif
  if ($variable2$ != "&lt;YOUR_CONDITION2&gt;")
    ; React when invalid, e.g. by clearing state and fall back to some default
    $variable2$ = ""
  endif

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U064_STATESAVE_DSP_USP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY">DSP</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Save instance state (DSP,USP)</DAT>
<DAT name="UALT_NAME" xml:space='preserve'>&lt;t&gt;&lt;z&gt;stateSave&lt;/z&gt;&lt;r&gt;&lt;s&gt;cpt&lt;/s&gt;&lt;x&gt;partner operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>; Save instance state
partner operation stateSave
throws
variables
  string vState
  string vEntityName1, vEntityName2
endvariables

  ; Encrypt your variables/properties if it contains sensitive data
  ; (Consider not to save sensitive data into cookies)
  ; (Consider to encrypt the complete state variable)
  $variable1$ = $encode("TDES", $variable1$, "YOUR_KEY")
  $variable2$ = $encode("TDES", $variable2$, "YOUR_KEY")
  ; ...

  ; Add variables and/or properties to the state variable, e.g.:
  putitem/id vState, "VAR1", $variable1$
  putitem/id vState, "VAR2", $variable2$
  putitem/id vState, "ENT_PROPS1", $entityproperties(vEntityName1)
  putitem/id vState, "ENT_PROPS2", $entityproperties(vEntityName2)
  ; ...

  ; Protect any variables/properties that are supposed to be read-only, e.g. by adding a hash:
  putitem/id vState, "HASH1", $encode("HMAC_MD5", $variable1$)
  ; ...

  ; State can be managed using different techniques.
  ; Architect the way state is maintained and chose the right technique for your application/component.
  ; It could also be a combination of multiple techniques.
  ; For example (The value of &lt;$cmpStateManagedBy&gt; is specified by component property 'State Stored By'):
  #if (&lt;$cmpStateManagedBy&gt; == 1)
    ; Save state to cookie(s):
    putitem vCookie, -1, vState
    ; Set cookie attributes
    ; putitem/id vCookie, "expires", Seconds
    ; putitem/id vCookie, "domain", Domain
    ; putitem/id vCookie, "path", Path
    ; putitem/id vCookie, "secure", "T" | "F"
    ; ...
    putitem/id $webinfo("COOKIESOUT"), $instancename, vCookie
    ; ...
  #elseif (&lt;$cmpStateManagedBy&gt; == 2)
    ; Save state to state manager:
    activate "USYSSTAT".setState($item("SESSION", $webinfo("WEBSERVERCONTEXT")), $instancename, vState)
    ; ...
  #elseif (&lt;$cmpStateManagedBy&gt; == 3)
    ; Save state from state field(s):
    STATE.ENTITY.NONDBMS = vState
    ; ...
  #else
    ; Some other state storage...
  #endif

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U110_ERRREPORT</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Adds any data errors to a report of type struct</DAT>
<DAT name="UALT_NAME" xml:space='preserve'>&lt;t&gt;&lt;z&gt;reportDataErrors&lt;/z&gt;&lt;r&gt;&lt;s&gt;coll&lt;/s&gt;&lt;x&gt;partner operation&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>partner operation reportDataErrors
throws
; This operation looks for any data errors in the current collection and adds them to the struct report.
; The error messages are expected to be available as $occproperties and $fieldproperties using the "errormsg" id.
; The value of the "errormsg" property is expected to be an indexed list with one or more error messages.
; The report is a struct and its structure represents the collection structure.
; This report activates this same operation for all its inner entities/collections.
;
; Use this report after data validation in service components, where a report needs to be returned to the caller.
; Return this report as a reference of the report struct; serialize to e.g. JSON first before returning.
; You can also use myDatapErrorReport-&gt;$dbgstring to write the report to a log in a human readable format.
; Interactive components, like DSPs, USPs, and FRMs read the errors directly from the data; no need to generate this report.
params
  byref struct pErrorReport: inout
endparams
variables
  struct vCollErrors, vOccErrors
  string vFieldName, vInnerEntityName, vErrorMsg, vMsg
endvariables

  ; Initialize the error report of the current collection and add it to the report struct
  pErrorReport-&gt;*{-1} = $newstruct
  vCollErrors = pErrorReport-&gt;*{-1}
  vCollErrors-&gt;$name = "&lt;$entname&gt;.&lt;$modelname&gt;"
  
  ; Iterate all occurrences of this collection.
  forentity "&lt;$entname&gt;"
    vCollErrors-&gt;*{-1} = $newstruct
    vOccErrors = vCollErrors-&gt;*{-1}
    vOccErrors-&gt;$name = "OCC%%($curocc(&lt;$entname&gt;))"

    ; Add occurrence errors (if any); includes any key errors
    getitem/id vErrorMsg, $occproperties(&lt;$entname&gt;), "errormsg"
    if ($status &gt; 0)
      forlist vMsg in vErrorMsg
        vOccErrors-&gt;"$error"{-1} = vErrorMsg
      endfor
    endif

    ; Add field errors (if any)
    forlist vFieldName in $entinfo(&lt;$entname&gt;, "PAINTEDFIELDS")
      getitem/id vErrorMsg, $fieldproperties("%%(vFieldname).&lt;$entname&gt;"), "errormsg"
      if ($status &gt; 0)
        vOccErrors-&gt;"%%(vFieldName)" = $newstruct
        vOccErrors-&gt;"%%(vFieldName)"-&gt;"$value" = @("%%(vFieldname).&lt;$entname&gt;")
        forlist vMsg in vErrorMsg
          vOccErrors-&gt;"%%(vFieldName)"-&gt;"$error"{-1} = vMsg
        endfor
      endif
    endfor
    
    ; Add errors of inner collections (if any)
    forlist vInnerEntityName in $entinfo(&lt;$entname&gt;, "INNER")
      $collhandle(vInnerEntityName)-&gt;reportDataErrors(vOccErrors)
    endfor

    ; Occurrence has no context -&gt; delete it
    if (vOccErrors-&gt;$membercount == 0)
      vOccErrors-&gt;$parent = ""
    endif
  endfor

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U211_READ</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs read from the DBMS (retrieve)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;read&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger read
throws
; This trigger is fired as part of the retrieve process.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.
variables
  string vOrderByFieldName, vParams, vOptions, vMaxHits, vOffset
  boolean vOrderDescending
endvariables
  
  if ($rettype == 78)
    ; Read the next occurrence
    read
  
  else
    ; Read the occurrence, e.g.:
    ; - Get order-by information from e.g. $entityproperties
    getitem/id vOrderByFieldName, $entityproperties(&lt;$entname&gt;), "ORDERBY_FIELDNAME"
    if ($status &gt; 0)
      getitem/id vOrderDescending, $entityproperties(&lt;$entname&gt;), "ORDERBY_DESCENDING"
      if (vOrderDescending)
        vOrderByFieldName = "%%(vOrderByFieldName) desc"
      else
        vOrderByFieldName = "%%(vOrderByFieldName)"
      endif
    endif
    ; - Get paging info from e.g. $entityproperties
    getitem/id vMaxHits, $entityproperties(&lt;$entname&gt;), "MAX_HITS"
    if ($status &gt; 0)
      putitem/id vOptions, "maxhits", vMaxHits
    endif
    getitem/id vOffset, $entityproperties(&lt;$entname&gt;), "OFFSET"
    if ($status &gt; 0)
      putitem/id vOptions, "offset", vOffset
    endif
    ; - Get U_CONDITION, U_WHERE, or WHERE from e.g. $entityproperties and perform read
    getitem/id vParams, $entityproperties(&lt;$entname&gt;), "U_CONDITION"
    if ($status &gt; 0)
      read options vOptions u_condition (vParams) order by vOrderByFieldName
    else
      getitem/id vParams, $entityproperties(&lt;$entname&gt;), "U_WHERE"
      if ($status &gt; 0)
        read options vOptions u_where (vParams) order by vOrderByFieldName
      else
        getitem/id vParams, $entityproperties(&lt;$entname&gt;), "WHERE"
        if ($status &gt; 0)
          read options vOptions where (vParams) order by vOrderByFieldName
        else
          read options vOptions order by vOrderByFieldName
        endif
      endif
    endif
  endif

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U211_WRITE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs that need to be written to DBMS (store)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;write&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger write
throws
; This trigger is fired when Uniface writes the occurrences to the database, typically as part of a store.

  ; Your last moment field updates here, e.g.:
  ; TIMESTAMP.&lt;$entname&gt; = $datim

  write

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U211_WRITE_UP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for up-occs that need to be written to DBMS (store)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;writeUp&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger writeUp
throws
; This trigger is fired when Uniface writes an occurrence of an up entity to the database, typically as part of a store.

  ; Your last moment field updates here, e.g.:
  ; TIMESTAMP.&lt;$entname&gt; = $datim

  write

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U212_DELETE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs that need to be deleted from the DBMS</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;delete&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger delete
throws
; This trigger is fired when Uniface deletes the occurrences from the database, typically as part of a store or erase.

  delete

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U212_DELETEUP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for every up occ marked for deletion (statement store)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;deleteUp&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger deleteUp
throws
; This trigger is fired when Uniface deletes the occurrences of an up entity from the database, typically as part of a store or erase.

  delete

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U22_LOCK</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs with validation errors</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;lock&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger lock
throws
; This trigger is fired as part of a database lock request.
; Depending on the locking strategy and DBMS locking support, this can happen at different moments:
; - During read (using read/lock)
; - At field start modification on interactive Form component
; - At field assignment in ProcScript
; - During a reconnect of disconnected records
; By catching lock exceptions and return a negative value, Uniface is instructed to continue processing.
; By not catching lock exceptions Uniface will not continue processing.

  try
    lock
  catch &lt;UIOSERR_UPDATE_NOT_ALLOWED&gt;
    ; No write or delete permission for the table or file. The occurrence is read-only (cannot be locked)
    return -5
  catch &lt;UIOSERR_WRITE_FAILURE&gt;
    ; An error occurred while writing, updating, or deleting the table or file; for example, lack of disk space,
    ; no write permission, or violation of a database constraint
    ; Inform caller by returning -6 and continue processing
    return -6
  catch &lt;UIOSERR_DUPLICATE_KEY&gt;
    ; The key exists in the database but was not found in the hitlist. This occurs when the user tries to enter a duplicate key
    ; Inform caller by returning -7 and continue processing
    return -7
  catch &lt;UIOSERR_LOGON_ERROR&gt;
    ; DBMS logon error. This can occur if the database connection has been lost or the maximum number
    ; of DBMS logons has already been reached
    ; Inform caller by returning -9 and continue processing
    return -9
  catch &lt;UIOSERR_LOCK_DATA_MISMATCH&gt;
    ; Occurrence has been modified or removed since it was retrieved
    ; Reload the occurrence and continue processing
    reload
  catch &lt;UIOSERR_LOCKED&gt;
    ; Occurrence already locked; wait and try again
    ; Inform caller by returning -11 and continue processing
    return -11
  endtry

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U231_VALIDATE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs that need to be validated</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;validate&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger validate
throws
; This trigger is fired as part of the validation process and should be used to
; create occurrence-specific validation rules.
; Write one or more validation checks and return a unique negative number for every failing check;
; this negative number is used by the error trigger to report the error.
; Remove this trigger if no procedural validation is required.

  ; Your occurrence validation rules here...
  ; if (FIELD1 &gt; FIELD2)
  ;   return -1
  ; elseif (FIELD3 &lt; FIELD4)
  ;   return -2
  ; endif

  ; Validation is successful
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U232_VALIDATE_KEY</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for keys (prim/candidate) that need to be validated</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;validateKey&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger validateKey
throws
; This trigger is fired as part of the validation process and should be used to
; create primary and candidate key validation rules.
; Write one or more field validation checks and return a unique negative number for every failing check;
; this negative number is used by the error trigger to report the error.
; Remove this trigger if no key validation is required; note that the store might fail as a consequence.

  findkey "&lt;$entname&gt;", $curkey
  selectcase $status
  case 0
    ; No occurrence found with this key
    if ($foreign)
      ; Related one occurrence not found
      return -2
    endif
  case 1
    ; Occurrence with this key found in component
    if (!$foreign)
      ; Occurrence already exists in component
      return -3
    endif
  case 2
    ; Occurrence with this key found in DBMS
    if (!$foreign)
      ; Occurrence already exists in DBMS
      return -4
    endif
  elsecase
    return $status 
  endselectcase

  ; Validation is successful
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U233_ERROR_USP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>USP ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for occs with validation errors (USP)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;error&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger error
throws
; This trigger is fired when data validation of the current occurrence or key failed.
; This trigger should:
; - determine whether the validation error is to be ignored or not
;    - return &gt;=0 to indicate the error is to be ignored
;    - return &lt;0 to indicate the error is not to be ignored
; - determine the error message
; - determine the fields involved with the error for reporting purposes
; - report the error message.
variables
  string vErrorMsg, vErrors, vErrorFields, vFieldName
  numeric vKeyNr
endvariables

  ; Use all fields as default involved fields
  vErrorFields = $entinfo(&lt;$entname&gt;, "PAINTEDFIELDS")

  ; Determine the error message and involved error fields
  selectcase $error
  case 0147
    ; Error caused by occurrence trigger validateKey
    vKeyNr = $item("KEY", $dataerrorcontext)
    vErrorFields = $keyfields(&lt;$entname&gt;, vKeyNr)
    selectcase $item("STATUS", $dataerrorcontext)
    case -2
      vErrorMsg = $concat($text("%%($error)"), " - Related one-occurrence not found")
    case -3
      vErrorMsg = $concat($text("%%($error)"), " - Occurrence with the same key (%%(vKeyNr)) exists in component")
    case -4
      vErrorMsg = $concat($text("%%($error)"), " - Occurrence with the same key (%%(vKeyNr)) already exists in DBMS")
    ; ...
    elsecase
      vErrorMsg = $text("%%($error)")
    endselectcase
  case 0153       
    ; Error caused by occurrence trigger validate
    selectcase $item("STATUS", $dataerrorcontext)
    case -1
      vErrorMsg = $concat($text("%%($error)"), " - Your error message for check 1 here")
      ; vErrorFields = "..."  ; The list of fields involved with the validation error
    ; case ...
      ; ...
    elsecase
      vErrorMsg = $text("%%($error)")
      ; vErrorFields = "..."  ; The list of fields involved with this check
    endselectcase
  ; case 2004       ; No modifications allowed on occurrence of this entity
  ; case 2009       ; Occurrence locked
  ; case 2012       ; Occurrence in form does not match database occurrence
  ; case 2013       ; Occurrence does not exist
  ; ...
  elsecase
    vErrorMsg = $text("%%($error)")
    ; vErrorFields = "..."  ; The list of fields involved with the validation error
  endselectcase

    ; For USP components, (multiple) data errors are reported and shown via the involved fields:
    forlist vFieldName in vErrorFields
      getitem/id vErrors, $fieldproperties("%%(vFieldName).&lt;$entname&gt;"), "errormsg"
      putitem vErrors, -1, vErrorMsg
      putitem/id $fieldproperties("%%(vFieldName).&lt;$entname&gt;"), "errormsg", vErrors
      putitem/id $fieldproperties("%%(vFieldName).&lt;$entname&gt;"), "SubClass", "errorstyle"
    endfor

  ; Return &gt;=0 to indicate the error is ignored
  ; Return &lt;0 to indicate the error is not ignored
  return -1

end</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U241_PRE_SERIALIZE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired before occ serialization (componentToStruct, xmlsave)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;preSerialize&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger preSerialize
throws
; This trigger is fired as part of the entity serialization process, caused by e.g. xmlsave.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U242_POST_SERIALIZE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired after occ serialization (componentToStruct, xmlsave)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;postSerialize&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger postSerialize
throws
; This trigger is fired as part of the entity serialization process, caused by e.g. xmlsave.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U243_PRE_DESERIALIZE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired before occ deserialization (StructToComponent, xmlload)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;preDeserialize&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger preDeserialize
throws
; This trigger is fired as part of the entity deserialization process, caused by e.g. xmlload.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U244_POST_DESERIALIZE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired after occ deserialization (StructToComponent, xmlload)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;postDeserialize&lt;/z&gt;&lt;r&gt;&lt;s&gt;occ&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger postDeserialize
throws
; This trigger is fired as part of the entity deserialization process, caused by e.g. xmlload.
; Make sure not to leave the context of this occurrence, it would disrupt the trigger flow and give unpredictable results.

; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U32_VALIDATE</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields that require validation</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;validate&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger validate
throws
; This trigger is fired as part of the validation process and should be used to create field-specific validation rules.
; Write one or more field validation checks and return a unique negative number for every failing check.
; This negative number is used by the error trigger to report the error.
; Remove this trigger if no procedural validation is required.

  ; Your field validation rules here...
  ; if (&lt;$fieldname&gt;.&lt;$entname&gt; &lt; 0)
  ;   return -1
  ; elseif (&lt;$fieldname&gt;.&lt;$entname&gt; &gt; 100)
  ;   return -2
  ; endif

  ; Validation is successful.
  return 0

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U34_ERROR_USP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>USP ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields with validation errors (USP)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;error&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger error
throws
; This trigger is fired when data validation of the current field failed.
; This trigger should:
; 1. determine whether the validation error is to be ignored or not
;    - return &gt;=0 to indicate the error is to be ignored
;    - return &lt;0 to indicate the error is not to be ignored
; 2. determine the error message
; 3. report the error message
variables
  string vErrorMsg, vDataErrorContext, vErrors
endvariables

  ; Determine error message
  selectcase $error
  case 0140
    ; Validation error caused by field trigger validate
    selectcase $item("STATUS", $dataerrorcontext)
    case -1
      ; vErrorMsg = $concat($text("%%($error)"), " - Check 1 in validate trigger failed")
      vErrorMsg = $concat($text("%%($error)"), " - Value must be between 0 and 100")
    case -2
      vErrorMsg = $concat($text("%%($error)"), " - Check 2 in validate trigger failed")
    elsecase
      vErrorMsg = $text("%%($error)")
    endselectcase
  ; case 0119       ; illegal ValRep value
  ; case 0120       ; subfield too large
  ; case 0121       ; subfield too small
  ; case 0122       ; incorrect checkdigit
  ; case 0123       ; illegal format for numeric field
  ; case 0124       ; illegal format for date field
  ; case 0125       ; illegal format for time field
  ; case 0126       ; illegal syntax format
  ; case 0127       ; illegal entry format
  ; case 0128       ; subfield too large to check
  ; case 0129       ; subfield(s) are required
  ; case 0130       ; too many subfields specified
  ; case 0138       ; illegal format for floating field
  ; ...
  elsecase
    vErrorMsg = $text("%%($error)")
  endselectcase

  ; For USP components, (multiple) data errors are reported and shown via the field:
  getitem/id vErrors, $fieldproperties(&lt;$fieldname&gt;.&lt;$entname&gt;), "errormsg"
  putitem vErrors, -1, vErrorMsg
  putitem/id $fieldproperties(&lt;$fieldname&gt;.&lt;$entname&gt;), "errormsg", vErrors
  putitem/id $fieldproperties(&lt;$fieldname&gt;.&lt;$entname&gt;), "SubClass", "errorstyle"

  ; Return &gt;=0 to indicate the error is ignored
  ; Return &lt;0 to indicate the error is not ignored
  return -1

end
</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U35_FORMAT_DBMS_FROM</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields that are read from the DBMS (read)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;formatFromDbms&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger formatFromDbms
throws
; This trigger is fired as part of the read from DBMS process.
; Make sure not to leave the context of this field, it would disrupt the trigger flow and give unpredictable results.

  ; Your conversion or decoding code here, e.g.:
  ; Data was stored encrypted using BLOWFISH in the DBMS, so decrypt it:
  &lt;$fieldname&gt;.&lt;$entname&gt; = $decode("BLOWFISH", &lt;$fieldname&gt;.&lt;$entname&gt;, "my secret key")

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U35_FORMAT_DBMS_TO</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP SVC ESV SSV ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields that are written to the DBMS (write)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;formatToDbms&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger formatToDbms
throws
; This trigger is fired as part of the write to DBMS process.
; Make sure not to leave the context of this field, it would disrupt the trigger flow and give unpredictable results.

  ; Your conversion or encoding code here, e.g.:
  ; Data is stored encrypted using BLOWFISH in the DBMS:
  &lt;$fieldname&gt;.&lt;$entname&gt; = $encode("BLOWFISH", &lt;$fieldname&gt;.&lt;$entname&gt;, "my secret key")

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U35_FORMAT_DISPLAY_FROM_FRMDSPUSP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM DSP USP ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields of which a value has been entered (DSP,USP,FRM)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;formatFromDisplay&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger formatFromDisplay
throws
; This trigger is fired as part of the data entry process.
; Make sure not to leave the context of this field, it would disrupt the trigger flow and give unpredictable results.
; var = $format - returns the value as entered by the user
; $format = var - assigns the converted value back to the internal administration of the system.

  ; Your display deformatting code here...

#ifdefined example_1
  ; 'GOLD-*' are displayed as regular '*' characters, convert them back on data entry
  $format = $replace($format, 1, "*", "&uALL;", -1)
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U35_FORMAT_DISPLAY_TO_FRMRPTDSPUSP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>FRM RPT DSP USP ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields that are displayed (DSP USP FRM RPT)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;formatToDisplay&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger formatToDisplay
throws
; This trigger is fired as part of the show process.
; Make sure not to leave the context of this field, it would disrupt the trigger flow and give unpredictable results.
; var = $format - returns the internal value of the field
; $format = var - assigns the formatted value back to the system for displaying.

  ; Your display formatting code here...

#ifdefined example_1
  ; Display 'GOLD-*' characters as regular '*' characters
  $format = $replace($format, 1, "&uALL;", "*", -1)
#endif

end

</DAT>
</OCC>
<OCC>
<DAT name="UNAME">U381_DETAIL_USP</DAT>
<DAT name="USYNTAX">PROCSCRIPT</DAT>
<DAT name="ULIBRARY">USCRIPT_USP</DAT>
<DAT name="UCATEGORY" xml:space='preserve'>USP ENT</DAT>
<DAT name="UKVERSION">7</DAT>
<DAT name="UMVERSION">2</DAT>
<DAT name="UDESCR" xml:space='preserve'>Fired for fields of which the button-widget gets pressed (USP)</DAT>
<DAT name="UALT_NAME">&lt;t&gt;&lt;z&gt;detail&lt;/z&gt;&lt;r&gt;&lt;s&gt;fld&lt;/s&gt;&lt;x&gt;trigger&lt;/x&gt;&lt;/r&gt;&lt;/t&gt;</DAT>
<DAT name="UTEXT" xml:space='preserve'>trigger detail
throws
public web
; Your SCOPE  block here (optional)...
; Your VARIABLES block here (optional)...

  ; Your implementation here...

end

</DAT>
</OCC>
</TABLE>
</UNIFACE>
